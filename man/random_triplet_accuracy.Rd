% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/triplet.R
\name{random_triplet_accuracy}
\alias{random_triplet_accuracy}
\title{Random Triplet Accuracy}
\usage{
random_triplet_accuracy(
  Xin,
  Xout,
  n_triplets = 5,
  metric_in = "l2sqr",
  metric_out = "l2sqr",
  is_transposed = FALSE,
  n_threads = 0,
  grain_size = 1
)
}
\arguments{
\item{Xin}{the input data (usually high-dimensional), a matrix or data frame
with one observation per row, or if \code{is_transposed = TRUE}, one observation
per column.}

\item{Xout}{the output data (usually lower dimensional than \code{Xin}), a matrix
or data frame with one observation per row, or if \code{is_transposed = TRUE},
one observation per column.}

\item{n_triplets}{the number of triplets per observation to generate.}

\item{metric_in}{the distance calculation to apply to \code{Xin}. One of
\code{"euclidean"}, \code{"l2sqr"} (squared Euclidean), \code{"cosine"}, \code{"manhattan"},
\code{"correlation"} (1 minus the Pearson correlation), or \code{"hamming"}.}

\item{metric_out}{the distance metric to apply to \code{Xout}. See \code{metric_in} for
details.}

\item{is_transposed}{if \code{TRUE} then \code{Xin} and \code{Xout} are assumed to have been
passed in transposed format, i.e. with one observation per column.
Otherwise, \code{Xin} and \code{Xout} will be transposed. For large datasets,
transposing can be slow, so if this function will be called multiple times
with the same input data, it is more efficient to transpose the input data
once outside of this function and set \code{is_transposed = TRUE}.}

\item{n_threads}{the maximum number of threads to use.}

\item{grain_size}{the minimum number of observations to be processed per
thread.}
}
\value{
The triplet accuracy, ranging from 0 (no relative distances agree) to
1 (all of them agree).
}
\description{
Evaluates the preservation of global structure of dimensionality reduction
results using the random triplet accuracy method of Wang and co-workers
(2020).
}
\details{
The random triplet accuracy is calculated by randomly selecting three points
in the input data and calculating the distances for two sides of the
resulting triangle. This is repeated for the output data, and the relative
ordering of the distances are compared. The returned accuracy is the
proportion of triangles where the relative distances agree between the input
and output data.
}
\examples{
iris_pca2 <- stats::prcomp(iris[, -5], rank. = 2, scale = FALSE, retx = TRUE)$x
random_triplet_accuracy(iris, iris_pca2)

# If you plan on comparing the results of multiple output methods, then
# pre-transposing the input data can save time
tiris <- t(iris[, -5])
iris_pca1 <- stats::prcomp(iris[, -5], rank. = 1, scale = FALSE, retx = TRUE)$x
iris_pca3 <- stats::prcomp(iris[, -5], rank. = 3, scale = FALSE, retx = TRUE)$x
random_triplet_accuracy(tiris, t(iris_pca1), is_transposed = TRUE)
random_triplet_accuracy(tiris, t(iris_pca2), is_transposed = TRUE)
random_triplet_accuracy(tiris, t(iris_pca3), is_transposed = TRUE)
}
\references{
Wang, Y., Huang, H., Rudin, C., & Shaposhnik, Y. (2021).
Understanding how dimension reduction tools work: an empirical approach to
deciphering t-SNE, UMAP, TriMAP, and PaCMAP for data visualization.
\emph{J Mach. Learn. Res}, \emph{22}, 1-73. \url{https://jmlr.org/papers/v22/20-1061.html}.
}
